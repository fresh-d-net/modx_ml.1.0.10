Мультиязычная версия ModxEvolution 1.0.10
==============

# Инициализация

## Точки входа
Существует три точки входа в приложение modx:
* /index.php - frontend
* /index-ajax.php - ajax-шлюз. Переработан под запуск сниппетов. Принимает два параметра:

?snippet=snip_name&data[var_name]=var_value

```php
$_REQUEST['snippet'];//имя сниппета
$_REQUEST['data'];//массив, который будет передан в сниппет
```

обратите внимание на 54 строку

```php
//это список поддерживаемых сниппетов для запуска через ajax-шлюз
//добавьте в него имя вашего сниппета если понадобится
$a_config['snippets_available'] = array('feedback', 'getPublications', 'order');
```
в более ранних версиях встречаются версии данного шлюза, которые поддерживают перечисленный в $a_config список методов

* /manager/index.php - frontend админка

Для каждой точки входа, кроме ajax-шлюза, инициализируется автолоатер классов:

```php
autoloader_init();
```
Класс самого автолоадера тут /manager/includes/autoloader.php
Ф-я инициализации вместе со спском директорий определена в /manager/includes/config.inc.php

## Конфигурация

Файл config.inc.php

В файл /manager/includes/config.inc.php включена константа MODX_DEBUG - определяющая режим дебага для системы в целом

Для мультиязычной версии в файле определяются настройки контекста (домена)

*Кроме вышеописанного способа настройки контекста - существует два дополнительных, 
которые встречаются в более ранних версиях.*

* *в корне сайта файл context_config.php*
* *в поле introtext корневых документов сайта. Массив представлен в виде json*

Небольшой пример конфигурации:
```php
$domain_config = array(
	"en.modx_10_ml.loc" => array( //домен отвечающий за языковую версию. Важно! Без www и http
		"culture_key" => "en",  //двухсимвольный языковой ключ контекста. Его значение определяет какой словарь будет подключен к системе 
		"site_url" => "http://en.modx_10_ml.loc/",  //замещает одноименную перенную [(site_url)]
		"site_start" => "4",  //замещает одноименную перенную [(site_start)]. Главная страница.
		"site_error" => "4", //замещает одноименную перенную [(site_error)]. Страница ошибки
		"site_root" => "2" //Корневой документ и-й языковой версии.
	)
);
```
Все настройки языковой версии (контекстов) попадают в массив $modx->config и в дальнейшем замещают плейсхолдеры системных настроек типа [(settings_name)] 

В самом конце файла определены ф-ии для инициализации автолоалера классов и exception_handler-а

## Экземпляр modx
Классический класс DocumentParser "обернут" в класс ModExt. Что дает возможность обновить DocumentParser и систему в целом.
```php
class ModExt extends DocumentParser{}
```
На страницах инициализации вызывается именно ModExt. В нем переопределены и отредактированы некоторые ключевые методы родителя
В последних версиях для инициализации modx используется паттерн singletone - поэтому, в любой момент времени получить
экзумпляр класса можно используя след вызов:

```php
ModExt::app();
```
В соответствии с паттерном прямой доступ к конструктору закрыт и разработчик не может создать несколько копий приложения.
На текущий момент данный подход позволяет обеспечить целостность системы:

* один контейнер с настройками
* одно соединение с БД
* возможность исключить переменную $modx из глобальной области видимости(полезно для плагинов)

```php
//Например, в плагинах больше не нужно использовать ключевое слово global для доступа к экземпляру modx
global $modx; //replace it to $modx = ModExt::app();
```


метод app либо вернет созданный ранее екземпляр, либо создаст его если это первый вызов.

**Обратите внимание**, что метод app принимает boolean-переменную $is_ajax, которая по умолчанию равна false
и определяет нужно ли "собирать" страницу или достаточно просто инициализировать приложение:
```php
$modx = ModExt::app($is_ajax=true)); //см. /index-ajax.php
```

## Структура шаблонов

Система, в разрез идеологии разработчиков, ориентирована на работу с файлами.
Сущность шаблона базируется на записи в таблице site_templates. В тело шаблона помещается запись вида:

@FILE assets/templates/some_dir/file.html

assets/templates/some_dir/file.html - является физическим файлом на сервере, куда и помещается привычный код шаблона

*Литерал конструкции "@FILE" унаследован от @-привязок [Modx](http://modx.ru/novosti-i-stati/article/37/) в TV-параметрах *

Шаблон может содержать вложенные ссылки на подшаблоны, которые также будут раскрыты.

**Обратите внимание** Парсингом @-привязок занимается плагин "File Source Template", который, в свою очередь,
отрабатывает на событие "OnParseDocument". Делайте выводы!

**Внимание!** Чтобы закрыть доступ к директории шаблонов со стороны клиента в /assets/templates помещен файл со след. содержанием:
```
deny from all
```

# Инструменты

## @-привязки в сниппетах

Существует три типа @-привязок для получения кода tpl-шаблона (содержащий плейсхолдеры вида [+name+]):

* @CODE:```<div>[+placeholder+]</div>```  - код
* @FILE:assets/templates/somedir/file - файл
* @TPL:assets/templates/somedir/file.tpl  - файл (@FILE - mirror)

*Данный литерал взят у классического сниппет систем modx - Wayfinder. Не забываем их использовать в файлоориентированной версии Modx*

Для получения шаблона необходимо обратится к методу ModExt::app()->getTpl()
```php
//В вызов сниппета передали:
$tpl="@CODE:<div>[+placeholder+]</div>";
//либо
$tpl="@FILE:assets/templates/somedir/file";
//либо
$tpl="chunk_name";

//начало кода сниппета
$s_tpl = isset($tpl) ? ModExt::app()->getTpl($tpl);
$s_tpl = isset($tpl) ? $modx->getTpl($tpl);//another way

```
В $tpl должна быть передана строка с @-привязкой либо имя чанка - в любом из вышеперечисленных способов мы получим содержимое шаблона.

## Структура client side

/assets/js/core.js - ядро реализующее декларативный стиль для jQuery библиотеки

### Пример

```Javascript
// assets/js/controllers/popup.obj.js
var Popup = {
	show: function(e){alert('popup is open');},
	close: function(e){alert('popup closed');},
}

```

```Javascript
// assets/js/plugins/jquery.myPlugin.js
$.fn.myPlugin = function(options){

var __constructor = function(options){}

return __constructor(options);
}

```
```html
<html>
<head>
<title>Title</title>

<script src="path/to/jquery.js"></script>

<script src="/assets/js/core.js"></script>

<script src="/assets/js/plugins/jquery.myPlugin.js"></script>

<script src="/assets/js/controllers/popup.obj.js"></script>

</head>
<body>

<a class="b-popup" data-click="Popup.show">Popup</a>

<div class="b-jqplugin" data-plugin="myPlugin" data-settings='{}'>Plugin</div>

</body>

</html>

```
Результат данного примера будет иметь следующее поведение.
* При клике на a.b-popup будет выведено сообщение "popup is open". Доступны след. бинды событий: click, change, submit 
* Для div.b-jqplugin будет инициализирован плагин myPlugin в который будут переданы опции из json-строки атрибута  data-settings

Данный подход позволяет разделить логику js-приложения на структуру файлов (и лишить разработчика "радости" наблюдать за извилистой простыней кода в $(document).ready()); инкапсулировать функционал в методы объектов.

## База данных
/#install/_db.sql - дамп базы данных

## Словари

В мультиязычной версии существуют языковые переменные - это некоторое регулярное выражение, которое заменяется при парсинге документа на строку соответствующую своему языковому контексту.
Пул языковых переменных представляет собой ассоциативный массив $lexicon объявленный в файле /assets/lexicon/[lang].inc.php, где [lang] код языка в формате ISO-2.

```php
$lexicon['var_name']='var_value';
```

### Переменные в шаблоне

Чтобы вывести языковую переменную необходимо использовать след. плейсхолдер:
```html
[%var_name]; <!---будет заменен на var_value
````

### Переменные в сниппете

Чтобы получить значение переменной, необходимо обратится к методу getLexicon:
```php
$modx->getLexicon('var_neme', ['ru']);// Второй атрибут - языковой контекст. По умолчанию равен текущему языку
```

По аналогии с modxRevo двузначній код языка (ru/ua/en) называется culture_key и определяется в массиве $domain_config файла /manager/includes/config.inc.php (см. [конфигурацию](https://github.com/fresh-d/modx_ml.1.0.10#%D0%9A%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F)).

## Сниппеты
Как было сказано ранее данный эдишн Modx файлоориентированный и сниппеты не стали исключением.
Запись о сниппете(имя, категирия) хранятся в БД но у каждого сниппета появилось доп. поле "Привязанный файл:"(см. вкладку "Свойства"). Здесь задается адрес файла в который будет помещатся код сниппета

**Внимание!** Путь указывается относительно директории /assets/snippets/

В момент сохранения сниппета отрабатывает плагин "SnippetFileSource" и в тело сниппета помещается include на файл указанный в поле "Привязанный файл:".

**Внимание!** Проследите, чтобы на момент разработки права на директории и файлы имели доступ на запись для групп

**Внимание!** Чтобы закрыть доступ к директории снипетов состороны клиента в /assets/snippets помещен файл со след. содержанием:
```
deny from all
```

# github
